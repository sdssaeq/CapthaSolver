"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.glob = exports.CACHE = void 0;
const fs = require("fs");
const globrex_1 = require("./globrex");
const globalyzer_1 = require("./globalyzer");
const path_1 = require("path");
const common_1 = require("./common");
exports.CACHE = {};
function walk(output, prefix, lexer, opts, dirname = '', level = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const rgx = lexer.segments[level];
        const dir = (0, path_1.resolve)(opts.cwd, prefix, dirname);
        let files = [];
        try {
            files = yield fs.promises.readdir(dir);
        }
        catch (_e) { }
        const { dot, filesOnly } = opts;
        for (const file of files) {
            const fullpath = (0, path_1.join)(dir, file);
            const relpath = dirname ? (0, path_1.join)(dirname, file) : file;
            if (!dot && common_1.isHidden.test(relpath))
                continue;
            const isMatch = lexer.regex.test(relpath);
            let isDir = exports.CACHE[relpath];
            if (isDir === undefined) {
                try {
                    isDir = (yield fs.promises.lstat(fullpath)).isDirectory();
                }
                catch (e) {
                    // no access
                    isDir = false;
                }
                exports.CACHE[relpath] = isDir;
            }
            if (!isDir) {
                isMatch && output.push((0, path_1.relative)(opts.cwd, fullpath));
                continue;
            }
            if (rgx && !rgx.test(file))
                continue;
            if (!filesOnly && isMatch)
                output.push((0, path_1.join)(prefix, relpath));
            if (rgx && rgx.toString() !== lexer.globstar)
                yield walk(output, prefix, lexer, opts, relpath, level + 1);
            // await walk(output, prefix, lexer, opts, relpath, rgx && rgx.toString() !== lexer.globstar && level + 1);
        }
    });
}
/**
 * Find files using bash-like globbing.
 * All paths are normalized compared to node-glob.
 * @param str Glob string
 * @returns array containing matching files
 */
function glob(str, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!str)
            return [];
        const glob = (0, globalyzer_1.default)(str);
        opts.cwd = opts.cwd || '.';
        const opts2 = opts;
        if (!glob.isGlob) {
            try {
                const resolved = (0, path_1.resolve)(opts.cwd, str);
                const dirent = yield fs.promises.stat(resolved);
                if (opts2.filesOnly && !dirent.isFile())
                    return [];
                return opts2.absolute ? [resolved] : [str];
            }
            catch (err) {
                const e = err;
                if (e.code != 'ENOENT')
                    throw err;
                return [];
            }
        }
        if (opts2.flush)
            exports.CACHE = {};
        let matches = [];
        const { path } = (0, globrex_1.default)(glob.glob, { filepath: true, globstar: true, extended: true });
        if (!path)
            return [];
        const globstar = path.globstar;
        // console.log({ path });
        path.globstar = globstar.toString();
        yield walk(matches, glob.base, path, opts2, '.', 0);
        if (opts2.absolute)
            matches = matches.map(x => (0, path_1.resolve)(opts2.cwd, x));
        return matches;
    });
}
exports.glob = glob;
;
exports.default = glob;
